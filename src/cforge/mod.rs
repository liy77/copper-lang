pub mod kson;
pub mod properties;
pub mod fetch;
pub mod vprint;

use std::{fs, path, process::Command};
use colored::Colorize;
use once_cell::sync::Lazy;

use crate::{parser, tokenizer::tokenizer::Tokenizer, vprint};

pub const VERSION: &str = "0.1.0";
pub const COPPER_PATH: Lazy<String> = Lazy::new(|| std::env::var("COPPER_PATH").unwrap());

pub fn get_copper_version() -> String {
    let path = std::path::Path::new(&(*COPPER_PATH)).join("Cargo.toml");
    
    // Try to read Cargo.toml from installation directory, fallback to default version
    if let Ok(toml_content) = fs::read_to_string(&path) {
        if let Some(version_start) = toml_content.find("version = \"") {
            let version_start = version_start + "version = \"".len();
            if let Some(version_end) = toml_content[version_start..].find("\"") {
                return toml_content[version_start..version_start + version_end].to_string();
            }
        }
    }
    
    // Fallback to hardcoded version if Cargo.toml is not found (installed version)
    "0.1.0-alpha.1".to_string()
}

pub fn print() {
    println!("{}", *COPPER_PATH);
    let cargo_output = if cfg!(windows) {
        Command::new("where")
            .arg("cargo")
            .output()
            .unwrap_or_else(|_| panic!("Failed to execute 'where cargo'"))
    } else {
        Command::new("which")
            .arg("cargo")
            .output()
            .unwrap_or_else(|_| panic!("Failed to execute 'which cargo'"))
    };

    let cargo_path = String::from_utf8_lossy(&cargo_output.stdout);
    
    vprint!("üì¶ Cargo found at: {}", cargo_path.trim().blue());

    let rustc_output = if cfg!(windows) {
        Command::new("where")
            .arg("rustc")
            .output()
            .unwrap_or_else(|_| panic!("Failed to execute 'where rustc'"))
    } else {
        Command::new("which")
            .arg("rustc")
            .output()
            .unwrap_or_else(|_| panic!("Failed to execute 'which rustc'"))
    };
    
    let rustc_path = String::from_utf8_lossy(&rustc_output.stdout);

    vprint!("ü¶Ä Rustc found at: {}", rustc_path.trim().blue());
    vprint!("Using CForge v{}", VERSION);
    vprint!("Using Copper v{}", get_copper_version());
}

pub fn compile(files: Vec<String>, input_dir: Option<String>, output_dir: Option<String>) -> Vec<String> {
    let copper_version = get_copper_version();
    let mut all_dependencies = Vec::new();

    for mut file in files {
        file = file.replace(path::MAIN_SEPARATOR_STR, "/");
        vprint!("üî® Compiling {}", file);

        let c = fs::read(&file).unwrap();
        let c = String::from_utf8(c).unwrap();

        let mut tokenizer = Tokenizer::new(c);
        let tokens = tokenizer.tokenize();
        let mut parser = parser::Parser::new(tokens);
        let result_code = parser.parse();
        
        // Coletar depend√™ncias detectadas
        let dependencies = parser.get_required_dependencies();
        for dep in dependencies {
            if !all_dependencies.contains(&dep) {
                all_dependencies.push(dep);
            }
        }

        let basepath = &format!("{}/rust/src/", output_dir.clone().unwrap_or("./dist".to_string()));
        fs::create_dir_all(basepath).unwrap();

        let mut path = format!("{}{}", basepath, file);
        path = path.replace(".crs", ".rs").replace("\\", "/");

        if let Some(ref input_dir) = input_dir {
            let input_dir = input_dir.clone().replace("\\", "/").replace(".crs", ".rs");
            path = path.replacen(&(input_dir+"/"), "", 1);
        }
        
        let result = format!("// Generated by CForge v{} with Copper v{}\n{}", VERSION, copper_version, result_code);
        // Create directories recursively if they don't exist
        let path_obj = std::path::Path::new(&path);
        
        if let Some(parent) = path_obj.parent() {
            fs::create_dir_all(parent).unwrap();
        }
        fs::write(path.clone(), result).unwrap();

        vprint!("  {} {} {}", file, "=>".yellow(), path);
    }

    println!("‚úÖ Successfully compiled");
    all_dependencies
}

pub fn get_toml_package_name() -> String {
    let toml =  fs::read("./dist/rust/Cargo.toml").unwrap();
    let toml = String::from_utf8(toml).unwrap();

    let name = toml.split("name = \"").collect::<Vec<&str>>()[1].split("\"").collect::<Vec<&str>>()[0];

    return name.to_string();
}

pub fn get_toml_package_version() -> String {
    let toml =  fs::read("./dist/rust/Cargo.toml").unwrap();
    let toml = String::from_utf8(toml).unwrap();

    let version = toml.split("version = \"").collect::<Vec<&str>>()[1].split("\"").collect::<Vec<&str>>()[0];

    return version.to_string();
}

pub fn run() {
    println!("üöÄ Building and running project...");
    
    let build_result = std::process::Command::new("cargo")
        .arg("build")
        .current_dir("./dist/rust")
        .output()
        .expect("Failed to execute cargo build");

    if !build_result.status.success() {
        let stderr = String::from_utf8_lossy(&build_result.stderr);
        println!("‚ùå Build failed:\n\n{}", stderr);
        return;
    }

    println!("‚úÖ Build successful");

    let run = std::process::Command::new("cargo")
        .arg("run")
        .current_dir("./dist/rust")
        .output()
        .expect("Failed to execute cargo run");

    if run.status.success() {
        let stdout = String::from_utf8_lossy(&run.stdout);
        println!("Running {} v{}:\n\n{}", get_toml_package_name().bold(), get_toml_package_version().bold(), stdout);
    } else {
        let stderr = String::from_utf8_lossy(&run.stderr);
        println!("‚ùå Error running compiled project:\n\n{}", stderr);
    }
}

pub async fn generate_toml(extra_dependencies: Vec<String>) {
    let properties = kson::read_properties(std::env::current_dir().unwrap().join("properties.kson").to_str().unwrap());
    let toml: String;

    vprint!("üîç Debug: properties.0 (is_toml): {}", properties.0);
    vprint!("üîç Debug: properties.1 JSON: {}", serde_json::to_string_pretty(&properties.1).unwrap_or_else(|_| "Failed to serialize".to_string()));

    if properties.0 {
        println!("‚ö†Ô∏è  Warning: Detected Cargo.toml file. CForge now uses properties.kson as the main configuration file. Please migrate your configuration to properties.kson. See https://copper-lang.org/docs/cforge/properties for more information.");
        let mut properties_obj = properties::Properties::from_toml(&properties.1).await;
        
        // Add extra detected dependencies
        for dep in extra_dependencies {
            properties_obj.add_dependency(&dep, "latest").await;
        }
        
        toml = properties_obj.to_toml();
        vprint!("Using Cargo.toml for configuration");
    } else {
        let mut properties_obj = properties::Properties::from_kson(&properties.1).await;

        // Add extra detected dependencies
        for dep in extra_dependencies {
            properties_obj.add_dependency(&dep, "latest").await;
        }
        
        toml = properties_obj.to_toml();
        vprint!("Using properties.kson for configuration");
    }

    fs::write("./dist/rust/Cargo.toml", toml).unwrap();
    vprint!("üì¶ Cargo.toml generated")
}
