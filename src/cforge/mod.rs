pub mod kson;
pub mod properties;
pub mod fetch;
pub mod vprint;

use std::{fs, path, process::Command};
use colored::Colorize;
use once_cell::sync::Lazy;

use crate::{parser, tokenizer::tokenizer::Tokenizer, vprint};

pub const VERSION: &str = "0.1.0";
pub const COPPER_PATH: Lazy<String> = Lazy::new(|| std::env::var("COPPER_PATH").unwrap());

pub fn get_copper_version() -> String {
    let path = std::path::Path::new(&(*COPPER_PATH)).join("Cargo.toml");
    let toml = fs::read(path.to_str().unwrap()).unwrap();
    let toml = String::from_utf8(toml).unwrap();

    let version = toml.split("version = \"").collect::<Vec<&str>>()[1].split("\"").collect::<Vec<&str>>()[0];

    return version.to_string();
}

pub fn print() {
    println!("{}", *COPPER_PATH);
    let cargo_output = if cfg!(windows) {
        Command::new("where")
            .arg("cargo")
            .output()
            .unwrap_or_else(|_| panic!("Failed to execute 'where cargo'"))
    } else {
        Command::new("which")
            .arg("cargo")
            .output()
            .unwrap_or_else(|_| panic!("Failed to execute 'which cargo'"))
    };

    let cargo_path = String::from_utf8_lossy(&cargo_output.stdout);
    
    vprint!("ðŸ“¦ Cargo found at: {}", cargo_path.trim().blue());

    let rustc_output = if cfg!(windows) {
        Command::new("where")
            .arg("rustc")
            .output()
            .unwrap_or_else(|_| panic!("Failed to execute 'where rustc'"))
    } else {
        Command::new("which")
            .arg("rustc")
            .output()
            .unwrap_or_else(|_| panic!("Failed to execute 'which rustc'"))
    };
    
    let rustc_path = String::from_utf8_lossy(&rustc_output.stdout);

    vprint!("ðŸ¦€ Rustc found at: {}", rustc_path.trim().blue());
    vprint!("Using CForge v{}", VERSION);
    vprint!("Using Copper v{}", get_copper_version());
}

pub fn compile(files: Vec<String>, input_dir: Option<String>, output_dir: Option<String>) {
    let copper_version = get_copper_version();

    for mut file in files {
        file = file.replace(path::MAIN_SEPARATOR_STR, "/");
        vprint!("ðŸ”¨ Compiling {}", file);

        let c = fs::read(&file).unwrap();
        let c = String::from_utf8(c).unwrap();

        let mut tokenizer = Tokenizer::new(c);
        let tokens = tokenizer.tokenize();
        let result = parser::parse(tokens);

        let basepath = &format!("{}/rust/src/", output_dir.clone().unwrap_or("./dist".to_string()));
        fs::create_dir_all(basepath).unwrap();

        let mut path = format!("{}{}", basepath, file);
        path = path.replace(".crs", ".rs").replace("\\", "/");

        if let Some(ref input_dir) = input_dir {
            let input_dir = input_dir.clone().replace("\\", "/").replace(".crs", ".rs");
            path = path.replacen(&(input_dir+"/"), "", 1);
        }
        let result = format!("// Generated by CForge v{} with Copper v{}\n{}", VERSION, copper_version, result);
        // Create directories recursively if they don't exist
        let path_obj = std::path::Path::new(&path);
        
        if let Some(parent) = path_obj.parent() {
            fs::create_dir_all(parent).unwrap();
        }
        fs::write(path.clone(), result).unwrap();

        vprint!("  {} {} {}", file, "=>".yellow(), path);
    }

    println!("âœ… Successfully compiled");
}

pub fn get_toml_package_name() -> String {
    let toml =  fs::read("./dist/rust/Cargo.toml").unwrap();
    let toml = String::from_utf8(toml).unwrap();

    let name = toml.split("name = \"").collect::<Vec<&str>>()[1].split("\"").collect::<Vec<&str>>()[0];

    return name.to_string();
}

pub fn get_toml_package_version() -> String {
    let toml =  fs::read("./dist/rust/Cargo.toml").unwrap();
    let toml = String::from_utf8(toml).unwrap();

    let version = toml.split("version = \"").collect::<Vec<&str>>()[1].split("\"").collect::<Vec<&str>>()[0];

    return version.to_string();
}

pub fn run() {
    let run = std::process::Command::new("cargo")
        .arg("run")
        .current_dir("./dist/rust")
        .output()
        .expect("ERROR");

    if run.status.success() {
        let stdout = String::from_utf8_lossy(&run.stdout);
        println!("Running {} v{}:\n\n{}", get_toml_package_name().bold(), get_toml_package_version().bold(), stdout);
    } else {
        let stderr = String::from_utf8_lossy(&run.stderr);
        println!("Error running compiled main file:\n\n{}", stderr);
    }
}

pub async fn generate_toml() {
    let properties = kson::read_properties(std::env::current_dir().unwrap().join("properties.kson").to_str().unwrap());
    let properties_obj = properties::Properties::from_kson(&properties).await;

    let toml = properties_obj.to_toml();

    fs::write("./dist/rust/Cargo.toml", toml).unwrap();
    vprint!("ðŸ“¦ Cargo.toml generated")
}
